{\rtf1\ansi\ansicpg1252\cocoartf2511
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Regular;\f2\fmodern\fcharset0 Courier;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue0;\red71\green138\blue206;
\red203\green203\blue202;\red212\green213\blue153;\red141\green213\blue254;\red88\green137\blue67;\red183\green111\blue179;
\red202\green202\blue202;\red89\green138\blue67;\red167\green197\blue152;\red183\green111\blue179;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\csgray\c0\c0;\cssrgb\c34146\c61677\c84338;
\cssrgb\c83320\c83320\c83112;\cssrgb\c86247\c86215\c66392;\cssrgb\c61545\c86704\c99884;\cssrgb\c41481\c59899\c33082;\cssrgb\c77407\c52698\c75307;
\cssrgb\c83137\c83137\c83137;\cssrgb\c41569\c60000\c33333;\cssrgb\c70980\c80784\c65882;\cssrgb\c77255\c52549\c75294;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf2 \cb3 \
metric proposed by Ploumis, Boitard, Jacquemin, Damberg, Ballestad, Nasiopoulos in \'84Quantitative Evaluation and Attribute of Overall Brightness in High Dynamic Range World\'93\
\
Direkt als Python Funktion benutzen, anstatt \'84von hand\'93 zu implementieren!!\
Mittlere Abweichung ist die \'84variance\'93\
GM = geometrisches Mittel\
\
\
\
\pard\pardeftab720\sl360\partightenfactor0

\f1 \cf2 \expnd0\expndtw0\kerning0
def gm_log(self, img):\
\
        img_list = img.tolist()\
        # slice 3d-image-array into 1d-array\
        img_slice = img\
        for x, y, z in np.nditer(img_slice):\
            print(x)\
\
        math.exp(math.fsum(math.log(x) for x in img_slice) / len(img_slice))\
        return \
\
__________________\
\
Geo mean for grey scale images\
        ksize = 5\
        geomean_grey = np.uint8(np.exp(cv2.boxFilter(np.log(img), -1, (ksize, ksize))))\
\
\
\pard\pardeftab720\sl360\partightenfactor0
\cf2 \outl0\strokewidth0 \strokec10 \
        \
\strokec11 # geometirisches mittel f\'fcr 5x5 pixel-cluster\strokec10 \
        ksize = \strokec12 5\strokec10 \
        \strokec11 # note: need fload numbers as input!\strokec10 \
        geomean_red = np.uint8(np.exp(cv2.boxFilter(np.log(img), -\strokec12 1\strokec10 , (ksize, ksize))))\
        \strokec13 return\strokec10  geomean_red\
\pard\pardeftab720\sl360\partightenfactor0

\f0 \cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 \
:____________________________________\
\
\
MULTI THREADING\
\
\pard\pardeftab720\sl280\partightenfactor0

\f2 \cf2 \cb1 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 from multiprocessing.pool import ThreadPool
\f0 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 \
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
\pard\pardeftab720\sl280\partightenfactor0

\f2 \cf2 \cb1 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 import concurrent.futures\
import math\
\
PRIMES = [\
    112272535095293,\
    112582705942171,\
    112272535095293,\
    115280095190773,\
    115797848077099,\
    1099726899285419]\
\
def is_prime(n):\
    if n < 2:\
        return False\
    if n == 2:\
        return True\
    if n % 2 == 0:\
        return False\
\
    sqrt_n = int(math.floor(math.sqrt(n)))\
    for i in range(3, sqrt_n + 1, 2):\
        if n % i == 0:\
            return False\
    return True\
\
def main():\
    with concurrent.futures.ProcessPoolExecutor() as executor:\
        for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)):\
            print('%d is prime: %s' % (number, prime))\
\
if __name__ == '__main__':\
    main()\
\
_____________-\
\
\pard\pardeftab720\sl280\partightenfactor0
\cf2 args = ((a, b) for b in c)\
for result in executor.map(lambda p: f(*p), args):   # (*p) does the unpacking part\
    pass\
\pard\pardeftab720\sl280\partightenfactor0
\cf2 ______________\
\
\pard\pardeftab720\sl280\partightenfactor0
\cf2 args = ((a, b) for b in c)\
for result in executor.map(f, args):\
    pass\
\pard\pardeftab720\sl280\partightenfactor0
\cf2 \
}