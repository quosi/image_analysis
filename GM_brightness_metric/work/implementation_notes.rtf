<<<<<<< HEAD
{\rtf1\ansi\ansicpg1252\cocoartf2511
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica-Bold;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
\f3\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red255\green255\blue255;\red0\green0\blue0;
\red13\green57\blue121;\red202\green202\blue202;\red89\green138\blue67;\red167\green197\blue152;\red183\green111\blue179;
}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c100000\c100000\c100000;\csgray\c0\c0;
\cssrgb\c4314\c29804\c54902;\cssrgb\c83137\c83137\c83137;\cssrgb\c41569\c60000\c33333;\cssrgb\c70980\c80784\c65882;\cssrgb\c77255\c52549\c75294;
}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\b\fs24 \cf2 \cb3 \
INFO: 
\f1\b0 \
\cb4 Metric proposed by Ploumis, Boitard, Jacquemin, Damberg, Ballestad, Nasiopoulos in \'84Quantitative Evaluation and Attribute of Overall Brightness in High Dynamic Range World\'93\
\

\f0\b SOURCE:\

\f1\b0 \
 {\field{\*\fldinst{HYPERLINK "https://www.researchgate.net/publication/337267269_Quantitative_Evaluation_and_Attribute_of_Overall_Brightness_in_a_High_Dynamic_Range_World"}}{\fldrslt \cf2 \cb4 \expnd0\expndtw0\kerning0
\ul \ulc2 \outl0\strokewidth0 \strokec5 https://www.researchgate.net/publication/337267269_Quantitative_Evaluation_and_Attribute_of_Overall_Brightness_in_a_High_Dynamic_Range_World}}\cf2 \cb4 \expnd0\expndtw0\kerning0
\ul \ulc2 \outl0\strokewidth0 \strokec5 \
\
\pard\pardeftab720\sl340\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://ieeexplore.ieee.org/document/8610037"}}{\fldrslt \cf2 \ulc2 https://ieeexplore.ieee.org/document/8610037}}\
\cf2 \cb3 \kerning1\expnd0\expndtw0 \ulnone \outl0\strokewidth0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf2 PRESENTATION of paper at SMPTE: \
https://www.youtube.com/watch?v=JcPv6KOPxFg\
\
\
\

\f0\b NOTES:
\f1\b0 \cb4 \
\
- Direkt als Python Funktion benutzen, anstatt \'84von hand\'93 zu implementieren!!\
Mittlere Abweichung ist die \'84variance\'93\
- GM = geometrisches Mittel\
\

\f0\b CODE:
\f1\b0 \
\
\pard\pardeftab720\sl360\partightenfactor0

\f2 \cf2 \expnd0\expndtw0\kerning0
def gm_log(self, img):\
\
        img_list = img.tolist()\
        # slice 3d-image-array into 1d-array\
        img_slice = img\
        for x, y, z in np.nditer(img_slice):\
            print(x)\
\
        math.exp(math.fsum(math.log(x) for x in img_slice) / len(img_slice))\
        return \
\
__________________\
\
Geo mean for grey scale images\
        ksize = 5\
        geomean_grey = np.uint8(np.exp(cv2.boxFilter(np.log(img), -1, (ksize, ksize))))\
\
\
\pard\pardeftab720\sl360\partightenfactor0
\cf2 \
        \
# geometirisches mittel f\'fcr 5x5 pixel-cluster\
        ksize = 5\
        # note: need fload numbers as input!\
        geomean_red = np.uint8(np.exp(cv2.boxFilter(np.log(img), -1, (ksize, ksize))))\
        return geomean_red\
\pard\pardeftab720\sl360\partightenfactor0

\f1 \cf2 \kerning1\expnd0\expndtw0 \
:____________________________________\
\
\
MULTI THREADING\
\
\pard\pardeftab720\sl280\partightenfactor0

\f3 \cf2 \cb1 \expnd0\expndtw0\kerning0
from multiprocessing.pool import ThreadPool
\f1 \cb4 \kerning1\expnd0\expndtw0 \
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\

\f3 \cb1 \expnd0\expndtw0\kerning0
import concurrent.futures\
import math\
\
PRIMES = [\
    112272535095293,\
    112582705942171,\
    112272535095293,\
    115280095190773,\
    115797848077099,\
    1099726899285419]\
\
def is_prime(n):\
    if n < 2:\
        return False\
    if n == 2:\
        return True\
    if n % 2 == 0:\
        return False\
\
    sqrt_n = int(math.floor(math.sqrt(n)))\
    for i in range(3, sqrt_n + 1, 2):\
        if n % i == 0:\
            return False\
    return True\
\
def main():\
    with concurrent.futures.ProcessPoolExecutor() as executor:\
        for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)):\
            print('%d is prime: %s' % (number, prime))\
\
if __name__ == '__main__':\
    main()\
\
_____________-\
\
args = ((a, b) for b in c)\
for result in executor.map(lambda p: f(*p), args):   # (*p) does the unpacking part\
    pass\
______________\
\
args = ((a, b) for b in c)\
for result in executor.map(f, args):\
    pass\
\
}
=======

INFO: 
Metric proposed by Ploumis, Boitard, Jacquemin, Damberg, Ballestad, Nasiopoulos in „Quantitative Evaluation and Attribute of Overall Brightness in High Dynamic Range World“

SOURCE:

 https://www.researchgate.net/publication/337267269_Quantitative_Evaluation_and_Attribute_of_Overall_Brightness_in_a_High_Dynamic_Range_World

https://ieeexplore.ieee.org/document/8610037

PRESENTATION of paper at SMPTE: 
https://www.youtube.com/watch?v=JcPv6KOPxFg



NOTES:

- Direkt als Python Funktion benutzen, anstatt „von hand“ zu implementieren!!
Mittlere Abweichung ist die „variance“
- GM = geometrisches Mittel

CODE:

def gm_log(self, img):

        img_list = img.tolist()
        # slice 3d-image-array into 1d-array
        img_slice = img
        for x, y, z in np.nditer(img_slice):
            print(x)

        math.exp(math.fsum(math.log(x) for x in img_slice) / len(img_slice))
        return 

__________________

Geo mean for grey scale images
        ksize = 5
        geomean_grey = np.uint8(np.exp(cv2.boxFilter(np.log(img), -1, (ksize, ksize))))



        
# geometirisches mittel für 5x5 pixel-cluster
        ksize = 5
        # note: need fload numbers as input!
        geomean_red = np.uint8(np.exp(cv2.boxFilter(np.log(img), -1, (ksize, ksize))))
        return geomean_red

:____________________________________


MULTI THREADING

from multiprocessing.pool import ThreadPool
——————————

import concurrent.futures
import math

PRIMES = [
    112272535095293,
    112582705942171,
    112272535095293,
    115280095190773,
    115797848077099,
    1099726899285419]

def is_prime(n):
    if n < 2:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False

    sqrt_n = int(math.floor(math.sqrt(n)))
    for i in range(3, sqrt_n + 1, 2):
        if n % i == 0:
            return False
    return True

def main():
    with concurrent.futures.ProcessPoolExecutor() as executor:
        for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)):
            print('%d is prime: %s' % (number, prime))

if __name__ == '__main__':
    main()

_____________-

args = ((a, b) for b in c)
for result in executor.map(lambda p: f(*p), args):   # (*p) does the unpacking part
    pass
______________

args = ((a, b) for b in c)
for result in executor.map(f, args):
    pass

>>>>>>> f61045aff5e891e3cd7c841ea7d41b1fda5342e7
